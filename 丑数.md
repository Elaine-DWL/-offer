## 题目描述

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 

## 解题思路

这道题又是“自己想不出来”系列。

### 思路一

最暴力的思想，就是遍历1~N的每个数，判断(x%2==0 && x%3==0 && x%5===0)其是否为丑数。

### 思路二

看了《剑指offer》上的分析，才大致理解了思路。

根据丑数的定义，我们知道，一个丑数一定可以由比它小的某个丑数乘以2或3或5得到。

我们要维护一个已经找到的有序的丑数数组，记该数组中当前最大的丑数为T，那么如何求下一个丑数？
将已经排序的所有丑数分别×2，×3，×5，得到的所有数中，肯定由比T大的，也由比T小的，那么比T大的数中，最小的那个，就是我们要找的T的下一个丑数。

上面的做法其实有一些重复，假设目前已经求得得有序丑数序列为$\{1, 2, 3, 4, 5\}$，考虑X2的情况，我们可以得到候选序列$\{2, 4, 6, 8, 10\}$，而实际上很明显，后续序列中的2和4比当前有序丑数序列中最大的数更小，所以它俩肯定已经在我们已经求得的丑数序列中，所以说**×2操作得到的比现有丑数序列中最大元素还小的数是没意义的，因为它已经在我们的有序丑数序列中了**。同理，×3、×5情况类似。

当前有序丑数序列：{1, 2, 3, 4, **5**}

×2：                          {~~2, 4,~~ <u>6</u>, 8, 10}        删除2和4是因为它俩比5小

×3：                          {~~3,~~ <u>6</u>,  9, 12, 15}        删除23是因为它比5小

×5：                          {~~5~~, <u>10</u>, 15, 20, 25}        删除5是因为5已经在有序序列中

所有删去冗余的数后我们得到的三个集合(如上)中的数，都是比当前有序丑数序列中最大元素大的数，那么这三个集合中最小的那个数 6 也就是我们要求的 T=5 的下一个丑数。

注意这里得到的三个集合，其实都是有序的，要找最小的一个数，其实只要比较三个集合最前面的也就是最小的三个数就行了。

即，记 x2 、x3、x5得到的集合中，比T大的最小的元素分别记为M2，M3，M5。min(M2, M3, M5)即要求下一个丑数。

根据上述思路，写出如下代码：

```cpp
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        // 找出第index个丑数
        int pos=0;
        int m2, m3, m5;
        vector<int> res(index+1, 1);
        while(pos < index-1){
            int n=pos;
            while(n>-1){
                int flag=0;
                if(2*res[n] > res[pos]){//更新M2值
                    m2=2*res[n];
                    flag=1;
                } 
                if(3*res[n] > res[pos]){
                    m3=3*res[n];
                    flag=1;
                } 
                if(5*res[n] > res[pos]){
                     m5=5*res[n];
                    flag=1;
                }
                if(flag==0) break;//如果M2,M3,M5都没更新，说明正确的M2,M3,M5值都已经找到了
                n--;
            }
                int t = min(m2, min(m3, m5));
                res[++pos] = t;
        }
        return res[index-1];
    }
};
```

### 思路三

第三种思路是在牛客的讨论区学到的。相比思路一更加简洁。

还是以思路二中的例子继续，

当前有序丑数序列：{1, 2, 3, 4, **5**}

×2：                          {~~2, 4,~~ <u>6</u>, 8, 10}        删除2和4是因为它俩比5小

×3：                          {~~3,~~ <u>6</u>,  9, 12, 15}        删除23是因为它比5小

×5：                          {~~5~~, <u>10</u>, 15, 20, 25}        删除5是因为5已经在有序序列中

根据上面得分析，得到更新后的有序丑数序列为{1， 2， 3， 4， 5， 6}。如果按照思路二，接下来对这个新的有序序列所有元素分别×2，x3，x5。刚才是对{1，2，3，4，5}已经都乘了一遍，现在就是多了一个对数字6分别乘以这三个数，可想而知，新得到的这三个数肯定不会比上次集合筛选剩下来的数都小。

对于这三个集合都有，“我”在前面，肯定比你小，你新生成的丑数肯定更大，”我“被选上之后，才可能轮到你。

这种方法要好好理解一下，很奇妙。

```cpp
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        int pos=0;
        int p2=0, p3=0, p5=0;//分别表示，x2 x3 x5生成的集合中，当前候选数的位置
        vector<int> res(index+1, 1);
        while(pos < index-1){
            int t = min(res[p2]*2, min(res[p3]*3, res[p5]*5));
            if(t == res[p2]*2) p2++;
            if(t == res[p3]*3) p3++;
            if(t == res[p5]*5) p5++;
            res[++pos] = t;
        }
        return res[index-1];
    }
};
```





